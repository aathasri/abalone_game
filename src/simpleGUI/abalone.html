<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Abalone</title>
  <style>
    body { font-family: Arial, sans-serif; display: flex; justify-content: center; background-color: #f0f0f0; }
    #game-container { text-align: center; }
    #start-menu, #game-board { background: white; padding: 20px; border-radius: 10px; box-shadow: 0 0 10px rgba(0,0,0,0.1); }
    #game-board { display: none; }
    .option-group { margin: 20px 0; }
    .hex-container { display: inline-block; }
    .hex-row { display: flex; justify-content: center; }


    .hex-cell { position: relative; margin: 2px; width: 40px; height: 46px; } /* Added explicit size to match hex */
    .hex {
      width: 40px;
      height: 46px;
      background: #ddd;
      clip-path: polygon(50% 0%, 100% 25%, 100% 75%, 50% 100%, 0% 75%, 0% 25%);
      position: absolute;
      top: 0;
      left: 0;
      z-index: 1; /* Hex background lowest, removed text styling */
    }
    .marble {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 30px;
      height: 30px;
      border-radius: 50%;
      z-index: 2; /* Marble above hex */
    }
    .coordinate { /* New class for coordinates */
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: red;
      font-size: 12px;
      font-weight: bold;
      z-index: 3; /* Above marble */
    }
    .marble.black { background: black; }
    .marble.white { background: white; border: 1px solid #ccc; }
    .marble.empty { background: none; }
    .player-status { display: flex; justify-content: space-between; margin: 10px 0; }
    .status-indicator { display: inline-block; width: 15px; height: 15px; border-radius: 50%; margin-right: 5px; vertical-align: middle; }
    .black-indicator { background: black; }
    .white-indicator { background: white; border: 1px solid #ccc; }
    #move-input { margin: 20px 0; }
    button { padding: 10px 20px; background: #007BFF; color: white; border: none; border-radius: 5px; cursor: pointer; margin: 5px; }
    button:hover { background: #0056b3; }
    #pause-button.paused { background: #FF5733; }
    #move-log { max-height: 150px; overflow-y: auto; border: 1px solid #ccc; padding: 10px; margin: 10px 0; text-align: left; font-size: 14px; }
  </style>
</head>
<body>
<div id="game-container">
  <!-- Start Menu -->
  <div id="start-menu">
    <div class="option-group">
      <h2>Choose AI color</h2>
      <label><input type="radio" name="color" value="b" checked> Black</label>
      <label><input type="radio" name="color" value="w"> White</label>
    </div>
    <div class="option-group">
      <h2>Choose board layout</h2>
      <label><input type="radio" name="layout" value="1" checked> Default</label>
      <label><input type="radio" name="layout" value="2"> German</label>
      <label><input type="radio" name="layout" value="3"> Belgian</label>
    </div>
    <div class="option-group">
      <h2>Set Time Limits (seconds)</h2>
      <label>AI Move Time Limit: <input type="number" id="ai-time-limit" value="5" min="1" step="0.1"></label><br>
      <label>Human Move Time Limit: <input type="number" id="human-time-limit" value="10" min="1" step="0.1"></label>
    </div>
    <div class="option-group">
      <h2>Set Move Limit (per player)</h2>
      <label><input type="number" id="move-limit" value="50" min="1"></label>
    </div>
    <button id="start-button">Start Game</button>
  </div>

  <!-- Game Board -->
  <div id="game-board">
    <h1>Abalone</h1>
    <div id="game-info">
      <div class="player-status">
        <div><span class="status-indicator black-indicator"></span> Black: <span id="black-count">14</span> marbles</div>
        <div><span class="status-indicator white-indicator"></span> White: <span id="white-count">14</span> marbles</div>
      </div>
      <div id="current-turn">Current turn: <span id="current-player">Black</span></div>
      <div id="ai-timer-info">
        <div>Total AI Time: <span id="total-ai-time">0s</span></div>
      </div>
      <div id="status-message"></div>
    </div>
    <div id="board">
      <!-- Board will be generated by JavaScript -->
    </div>
    <div id="move-input">
      <input type="text" id="move-text" placeholder="Enter move (e.g., iA1NE)">
      <button id="submit-move">Submit Move</button>
    </div>
    <div id="move-log"></div>
    <button id="new-game">New Game</button>
    <button id="pause-button">Pause AI Timer</button>
    <button id="undo-move">Undo Move</button>
  </div>
</div>

<!-- Load WebAssembly module -->
<script src="trialgui.js"></script>
<script>
  // WebAssembly function wrappers
  let startGameFunc, getBoardStateFunc, makeAIMoveFunc, applyManualMoveFunc, undoLastMoveFunc;

  // Initialize WebAssembly module
  AbaloneModule().then(Module => {
    startGameFunc = Module.cwrap('startGame', null, ['number', 'number']);
    getBoardStateFunc = Module.cwrap('getBoardState', 'string', []);
    makeAIMoveFunc = Module.cwrap('makeAIMove', 'string', []); // Returns "move:result"
    applyManualMoveFunc = Module.cwrap('applyManualMove', 'number', ['string']);
    undoLastMoveFunc = Module.cwrap('undoLastMove', 'number', []);
    console.log("WebAssembly module loaded");
  }).catch(err => console.error("Failed to load WebAssembly module:", err));

  // Board positions mapping
  const boardPositions = [
    ["I5", "I6", "I7", "I8", "I9"],
    ["H4", "H5", "H6", "H7", "H8", "H9"],
    ["G3", "G4", "G5", "G6", "G7", "G8", "G9"],
    ["F2", "F3", "F4", "F5", "F6", "F7", "F8", "F9"],
    ["E1", "E2", "E3", "E4", "E5", "E6", "E7", "E8", "E9"],
    ["D1", "D2", "D3", "D4", "D5", "D6", "D7", "D8"],
    ["C1", "C2", "C3", "C4", "C5", "C6", "C7"],
    ["B1", "B2", "B3", "B4", "B5", "B6"],
    ["A1", "A2", "A3", "A4", "A5"]
  ];

  // Game state
  let gameState = {
    board: {},
    currentPlayer: 'b',
    aiColor: 'b',
    playerColor: 'w',
    blackCount: 14,
    whiteCount: 14,
    totalAITime: 0,
    aiMoveCount: 0,
    aiMoveStartTime: null,
    timerInterval: null,
    isPaused: false,
    moveNumber: 0,
    moveLog: [],
    aiTimeLimit: 5,
    humanTimeLimit: 10,
    moveLimit: 50
  };

  // Start button event
  document.getElementById('start-button').addEventListener('click', function () {
    const aiColorChoice = document.querySelector('input[name="color"]:checked').value;
    const layoutChoice = document.querySelector('input[name="layout"]:checked').value;
    gameState.aiTimeLimit = parseFloat(document.getElementById('ai-time-limit').value);
    gameState.humanTimeLimit = parseFloat(document.getElementById('human-time-limit').value);
    gameState.moveLimit = parseInt(document.getElementById('move-limit').value);

    gameState.aiColor = aiColorChoice;
    gameState.playerColor = aiColorChoice === 'b' ? 'w' : 'b';
    gameState.currentPlayer = 'b';
    gameState.totalAITime = 0;
    gameState.aiMoveCount = 0;
    gameState.aiMoveStartTime = null;
    gameState.isPaused = false;
    gameState.moveNumber = 0;
    gameState.moveLog = [];

    const aiColorNum = gameState.aiColor === 'b' ? 0 : 1;
    startGameFunc(aiColorNum, Number(layoutChoice));

    updateBoardFromWasm();
    document.getElementById('start-menu').style.display = 'none';
    document.getElementById('game-board').style.display = 'block';
    generateBoardHTML();
    updateBoardDisplay();
    updateGameInfo();
    updateTimerDisplay();
    updateMoveLog();

    if (gameState.currentPlayer === gameState.aiColor) {
      startAITimer();
      setTimeout(makeAIMove, 500);
    }
  });

  // New game button event
  document.getElementById('new-game').addEventListener('click', function () {
    clearInterval(gameState.timerInterval);
    gameState.totalAITime = 0;
    gameState.aiMoveCount = 0;
    gameState.aiMoveStartTime = null;
    gameState.isPaused = false;
    gameState.moveNumber = 0;
    gameState.moveLog = [];
    document.getElementById('pause-button').textContent = 'Pause AI Timer';
    document.getElementById('pause-button').classList.remove('paused');
    document.getElementById('game-board').style.display = 'none';
    document.getElementById('start-menu').style.display = 'block';
    updateTimerDisplay();
    updateMoveLog();
  });

  // Pause button event
  document.getElementById('pause-button').addEventListener('click', function () {
    gameState.isPaused = !gameState.isPaused;
    const pauseButton = document.getElementById('pause-button');
    if (gameState.isPaused) {
      pauseButton.textContent = 'Resume AI Timer';
      pauseButton.classList.add('paused');
      clearInterval(gameState.timerInterval);
    } else {
      pauseButton.textContent = 'Pause AI Timer';
      pauseButton.classList.remove('paused');
      if (gameState.currentPlayer === gameState.aiColor && gameState.aiMoveStartTime !== null) {
        startAITimer();
      }
    }
  });

  // Submit move button event (human player's turn)
  document.getElementById('submit-move').addEventListener('click', function () {
    if (gameState.currentPlayer !== gameState.playerColor) {
      document.getElementById('status-message').textContent = 'Not your turn!';
      return;
    }

    const moveText = document.getElementById('move-text').value.trim();
    if (moveText && isValidMoveFormat(moveText)) {
      const result = applyManualMoveFunc(moveText);
      if (result === -1) {
        document.getElementById('status-message').textContent = 'Invalid move!';
        return;
      }

      gameState.moveNumber++;
      gameState.moveLog.push(`${gameState.moveNumber}: ${gameState.playerColor === 'b' ? 'Black' : 'White'}:${moveText}`);
      document.getElementById('status-message').textContent = 'Move applied: ' + moveText;
      document.getElementById('move-text').value = '';
      updateBoardFromWasm();
      updateBoardDisplay();
      updateGameInfo();
      updateMoveLog();

      if (result === 1) {
        document.getElementById('status-message').textContent = 'White wins!';
        clearInterval(gameState.timerInterval);
        return;
      } else if (result === 2) {
        document.getElementById('status-message').textContent = 'Black wins!';
        clearInterval(gameState.timerInterval);
        return;
      }

      gameState.currentPlayer = gameState.aiColor;
      updateGameInfo();
      startAITimer();
      setTimeout(makeAIMove, 1000);
    } else {
      document.getElementById('status-message').textContent = 'Invalid move format!';
    }
  });

  // Undo move button event
  document.getElementById('undo-move').addEventListener('click', function () {
    if (gameState.moveNumber === 0) {
      document.getElementById('status-message').textContent = 'Nothing to undo!';
      return;
    }

    const result = undoLastMoveFunc();
    if (result === -1) {
      document.getElementById('status-message').textContent = 'Cannot undo initial state!';
      return;
    }

    gameState.moveNumber--;
    const lastMove = gameState.moveLog.pop();
    if (lastMove.includes('s)')) { // Rough check for AI move (includes time)
      gameState.aiMoveCount--;
      const moveTime = parseFloat(lastMove.split(':').pop().replace('s)', '')) * 1000;
      gameState.totalAITime -= moveTime;
    }
    gameState.currentPlayer = gameState.currentPlayer === 'b' ? 'w' : 'b';
    updateBoardFromWasm();
    updateBoardDisplay();
    updateGameInfo();
    updateTimerDisplay();
    updateMoveLog();
    document.getElementById('status-message').textContent = 'Move undone';
  });

  // Update board state from WebAssembly
  function updateBoardFromWasm() {
    const boardStr = getBoardStateFunc();
    gameState.board = {};
    const marbles = boardStr.split(',');
    for (const marble of marbles) {
      if (marble.length === 3) {
        const pos = marble.substring(0, 2);
        const color = marble.charAt(2);
        gameState.board[pos] = color;
      }
    }
    countMarbles();
  }

  // Count marbles
  function countMarbles() {
    gameState.blackCount = 0;
    gameState.whiteCount = 0;
    for (const pos in gameState.board) {
      if (gameState.board[pos] === 'b') gameState.blackCount++;
      else if (gameState.board[pos] === 'w') gameState.whiteCount++;
    }
  }

  // Generate HTML for the board
  function generateBoardHTML() {
    const boardElement = document.getElementById('board');
    boardElement.innerHTML = '';
    const hexContainer = document.createElement('div');
    hexContainer.className = 'hex-container';
    for (let i = 0; i < boardPositions.length; i++) {
      const row = document.createElement('div');
      row.className = 'hex-row';
      for (let j = 0; j < boardPositions[i].length; j++) {
        const cellPosition = boardPositions[i][j];
        const cell = document.createElement('div');
        cell.className = 'hex-cell';
        cell.dataset.position = cellPosition;
        const hex = document.createElement('div');
        hex.className = 'hex';
        const coord = document.createElement('div'); // New div for coordinates
        coord.className = 'coordinate';
        coord.textContent = cellPosition;
        const marble = document.createElement('div');
        marble.className = 'marble empty';
        marble.dataset.position = cellPosition;
        cell.appendChild(hex);
        cell.appendChild(marble);
        cell.appendChild(coord); // Add coordinates last
        row.appendChild(cell);
      }
      hexContainer.appendChild(row);
    }
    boardElement.appendChild(hexContainer);
  }

  // Update board display
  function updateBoardDisplay() {
    const marbles = document.querySelectorAll('.marble');
    marbles.forEach(marble => marble.className = 'marble empty');
    for (const position in gameState.board) {
      const color = gameState.board[position];
      const marble = document.querySelector(`.marble[data-position="${position}"]`);
      if (marble) marble.className = `marble ${color === 'b' ? 'black' : 'white'}`;
    }
  }

  // Update game info
  function updateGameInfo() {
    document.getElementById('black-count').textContent = gameState.blackCount;
    document.getElementById('white-count').textContent = gameState.whiteCount;
    document.getElementById('current-player').textContent = gameState.currentPlayer === 'b' ? 'Black' : 'White';
  }

  // AI move
  function makeAIMove() {
    document.getElementById('status-message').textContent = 'AI is thinking...';
    setTimeout(() => {
      const computeStartTime = performance.now(); // Time only computation
      const aiMoveResult = makeAIMoveFunc();
      const computeEndTime = performance.now();
      const moveTime = (computeEndTime - computeStartTime) / 1000; // Actual computation time
      gameState.totalAITime += moveTime * 1000; // Add in milliseconds
      gameState.aiMoveCount++;
      gameState.moveNumber++;

      const [aiMove, result] = aiMoveResult.split(':');
      if (moveTime > gameState.aiTimeLimit) {
        document.getElementById('status-message').textContent = `AI move took ${moveTime.toFixed(2)}s, exceeding ${gameState.aiTimeLimit}s limit!`;
      } else if (aiMove === "none") {
        document.getElementById('status-message').textContent = 'AI has no valid moves!';
      } else {
        document.getElementById('status-message').textContent = 'AI made a move: ' + aiMove;
      }

      if (aiMove !== "none") {
        gameState.moveLog.push(`${gameState.moveNumber}: ${gameState.aiColor === 'b' ? 'Black' : 'White'}:${aiMove}:${moveTime.toFixed(2)}s)`);
      }
      clearInterval(gameState.timerInterval);
      gameState.aiMoveStartTime = null;

      updateBoardFromWasm();
      updateBoardDisplay();
      updateGameInfo();
      updateTimerDisplay();
      updateMoveLog();

      const resultNum = parseInt(result);
      if (resultNum === 1) {
        document.getElementById('status-message').textContent = 'White wins!';
      } else if (resultNum === 2) {
        document.getElementById('status-message').textContent = 'Black wins!';
      } else if (resultNum === 0 && aiMove !== "none") {
        gameState.currentPlayer = gameState.playerColor;
        updateGameInfo();
      }
    }, 1000); // Simulated delay
  }



  // Start AI timer
  function startAITimer() {
    gameState.aiMoveStartTime = performance.now();
    if (!gameState.isPaused) {
      clearInterval(gameState.timerInterval);
      gameState.timerInterval = setInterval(updateTimerDisplay, 100);
    }
  }

  // Update timer display
  function updateTimerDisplay() {
    const totalSeconds = (gameState.totalAITime / 1000).toFixed(2);
    document.getElementById('total-ai-time').textContent = `${totalSeconds}s`;
  }

  // Update move log
  function updateMoveLog() {
    const moveLogElement = document.getElementById('move-log');
    moveLogElement.innerHTML = gameState.moveLog.join('<br>');
    moveLogElement.scrollTop = moveLogElement.scrollHeight;
  }

  // Move validation
  function isValidMoveFormat(move) {
    if (move.startsWith('i') && move.length >= 4) {
      const position = move.substring(1, 3);
      const direction = move.substring(3);
      return isValidPosition(position) && isValidDirection(direction);
    }
    if (move.startsWith('s') && move.length >= 6) {
      const position1 = move.substring(1, 3);
      const position2 = move.substring(3, 5);
      const direction = move.substring(5);
      return isValidPosition(position1) && isValidPosition(position2) && isValidDirection(direction);
    }
    return false;
  }

  function isValidPosition(pos) {
    if (pos.length !== 2) return false;
    const col = pos.charAt(0);
    const row = parseInt(pos.charAt(1));
    return col >= 'A' && col <= 'I' && row >= 1 && row <= 9;
  }

  function isValidDirection(dir) {
    const validDirections = ["NE", "E", "SE", "SW", "W", "NW"];
    return validDirections.includes(dir);
  }
</script>
</body>
</html>