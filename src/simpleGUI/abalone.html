<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Abalone Game</title>
  <style>
    body { font-family: Arial, sans-serif; display: flex; justify-content: center; background-color: #f0f0f0; }
    #game-container { text-align: center; }
    #start-menu, #game-board { background: white; padding: 20px; border-radius: 10px; box-shadow: 0 0 10px rgba(0,0,0,0.1); }
    #game-board { display: none; }
    .option-group { margin: 20px 0; }
    .hex-container { display: inline-block; }
    .hex-row { display: flex; justify-content: center; }
    .hex-cell { position: relative; margin: 2px; }
    .hex { width: 40px; height: 46px; background: #ddd; clip-path: polygon(50% 0%, 100% 25%, 100% 75%, 50% 100%, 0% 75%, 0% 25%); display: flex; align-items: center; justify-content: center; font-size: 12px; }
    .marble { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 30px; height: 30px; border-radius: 50%; }
    .marble.black { background: black; }
    .marble.white { background: white; border: 1px solid #ccc; }
    .marble.empty { background: none; }
    .player-status { display: flex; justify-content: space-between; margin: 10px 0; }
    .status-indicator { display: inline-block; width: 15px; height: 15px; border-radius: 50%; margin-right: 5px; vertical-align: middle; }
    .black-indicator { background: black; }
    .white-indicator { background: white; border: 1px solid #ccc; }
    #move-input { margin: 20px 0; }
    button { padding: 10px 20px; background: #007BFF; color: white; border: none; border-radius: 5px; cursor: pointer; }
    button:hover { background: #0056b3; }
  </style>
</head>
<body>
<div id="game-container">
  <!-- Start Menu -->
  <div id="start-menu">
<!--    <h1>Abalone</h1>-->
    <div class="option-group">
      <h2>Choose AI color</h2>
      <label><input type="radio" name="color" value="b" checked> Black</label>
      <label><input type="radio" name="color" value="w"> White</label>
    </div>
    <div class="option-group">
      <h2>Choose board layout</h2>
      <label><input type="radio" name="layout" value="1" checked> Default</label>
      <label><input type="radio" name="layout" value="2"> German</label>
      <label><input type="radio" name="layout" value="3"> Belgian</label>
    </div>
    <button id="start-button">Start Game</button>
  </div>

  <!-- Game Board -->
  <div id="game-board">
    <h1>Abalone Game</h1>
    <div id="game-info">
      <div class="player-status">
        <div><span class="status-indicator black-indicator"></span> Black: <span id="black-count">14</span> marbles</div>
        <div><span class="status-indicator white-indicator"></span> White: <span id="white-count">14</span> marbles</div>
      </div>
      <div id="current-turn">Current turn: <span id="current-player">Black</span></div>
      <div id="status-message"></div>
    </div>
    <div id="board">
      <!-- Board will be generated by JavaScript -->
    </div>
    <div id="move-input">
      <input type="text" id="move-text" placeholder="Enter move (e.g., iA1NE)">
      <button id="submit-move">Submit Move</button>
    </div>
    <button id="new-game" style="margin-top: 20px;">New Game</button>
  </div>
</div>

<!-- Load WebAssembly module -->
<script src="trialgui.js"></script>
<script>
  // WebAssembly function wrappers
  let startGameFunc, getBoardStateFunc, makeAIMoveFunc, applyManualMoveFunc;

  // Initialize WebAssembly module
  AbaloneModule().then(Module => {
    startGameFunc = Module.cwrap('startGame', null, ['number', 'number']);
    getBoardStateFunc = Module.cwrap('getBoardState', 'string', []);
    makeAIMoveFunc = Module.cwrap('makeAIMove', 'number', []);
    applyManualMoveFunc = Module.cwrap('applyManualMove', 'number', ['string']);
    console.log("WebAssembly module loaded");
  }).catch(err => console.error("Failed to load WebAssembly module:", err));

  // Board positions mapping
  const boardPositions = [
    ["I5", "I6", "I7", "I8", "I9"],
    ["H4", "H5", "H6", "H7", "H8", "H9"],
    ["G3", "G4", "G5", "G6", "G7", "G8", "G9"],
    ["F2", "F3", "F4", "F5", "F6", "F7", "F8", "F9"],
    ["E1", "E2", "E3", "E4", "E5", "E6", "E7", "E8", "E9"],
    ["D1", "D2", "D3", "D4", "D5", "D6", "D7", "D8"],
    ["C1", "C2", "C3", "C4", "C5", "C6", "C7"],
    ["B1", "B2", "B3", "B4", "B5", "B6"],
    ["A1", "A2", "A3", "A4", "A5"]
  ];

  // Game state
  let gameState = {
    board: {},
    currentPlayer: 'b', // 'b' for black, 'w' for white
    aiColor: 'b',       // AI's color (chosen by user)
    playerColor: 'w',   // Human's color (opposite of AI)
    blackCount: 14,
    whiteCount: 14
  };

  // Start button event
  document.getElementById('start-button').addEventListener('click', function () {
    const aiColorChoice = document.querySelector('input[name="color"]:checked').value;
    const layoutChoice = document.querySelector('input[name="layout"]:checked').value;

    gameState.aiColor = aiColorChoice;
    gameState.playerColor = aiColorChoice === 'b' ? 'w' : 'b';
    gameState.currentPlayer = 'b'; // Black always starts

    // Call C++ startGame (0 = Black, 1 = White for AI color)
    const aiColorNum = gameState.aiColor === 'b' ? 0 : 1;
    startGameFunc(aiColorNum, Number(layoutChoice));

    // Get initial board state from C++
    updateBoardFromWasm();

    // Hide start menu and show game board
    document.getElementById('start-menu').style.display = 'none';
    document.getElementById('game-board').style.display = 'block';

    // Generate and update UI
    generateBoardHTML();
    updateBoardDisplay();
    updateGameInfo();

    // If AI is Black, it starts with a random move
    if (gameState.currentPlayer === gameState.aiColor) {
      setTimeout(makeAIMove, 500);
    }
  });

  // New game button event
  document.getElementById('new-game').addEventListener('click', function () {
    document.getElementById('game-board').style.display = 'none';
    document.getElementById('start-menu').style.display = 'block';
  });

  // Submit move button event (human player's turn)
  document.getElementById('submit-move').addEventListener('click', function () {
    if (gameState.currentPlayer !== gameState.playerColor) {
      document.getElementById('status-message').textContent = 'Not your turn!';
      return;
    }

    const moveText = document.getElementById('move-text').value.trim();
    if (moveText && isValidMoveFormat(moveText)) {
      const result = applyManualMoveFunc(moveText);
      if (result === -1) {
        document.getElementById('status-message').textContent = 'Invalid move!';
        return;
      }

      document.getElementById('status-message').textContent = 'Move applied: ' + moveText;
      document.getElementById('move-text').value = '';

      // Update board state from WASM
      updateBoardFromWasm();
      updateBoardDisplay();
      updateGameInfo();

      // Check win condition from C++
      if (result === 1) {
        document.getElementById('status-message').textContent = 'White wins!';
        return;
      } else if (result === 2) {
        document.getElementById('status-message').textContent = 'Black wins!';
        return;
      }

      // Switch to AI's turn and update UI immediately
      gameState.currentPlayer = gameState.aiColor;
      updateGameInfo(); // Refresh UI to show AI's turn
      setTimeout(makeAIMove, 1000);
    } else {
      document.getElementById('status-message').textContent = 'Invalid move format!';
    }
  });

  // Update board state from WebAssembly
  function updateBoardFromWasm() {
    const boardStr = getBoardStateFunc();
    gameState.board = {};
    const marbles = boardStr.split(',');
    for (const marble of marbles) {
      if (marble.length === 3) {
        const pos = marble.substring(0, 2);
        const color = marble.charAt(2);
        gameState.board[pos] = color;
      }
    }
    countMarbles();
  }

  // Count marbles
  function countMarbles() {
    gameState.blackCount = 0;
    gameState.whiteCount = 0;
    for (const pos in gameState.board) {
      if (gameState.board[pos] === 'b') gameState.blackCount++;
      else if (gameState.board[pos] === 'w') gameState.whiteCount++;
    }
  }

  // Generate HTML for the board
  function generateBoardHTML() {
    const boardElement = document.getElementById('board');
    boardElement.innerHTML = '';
    const hexContainer = document.createElement('div');
    hexContainer.className = 'hex-container';
    for (let i = 0; i < boardPositions.length; i++) {
      const row = document.createElement('div');
      row.className = 'hex-row';
      for (let j = 0; j < boardPositions[i].length; j++) {
        const cellPosition = boardPositions[i][j];
        const cell = document.createElement('div');
        cell.className = 'hex-cell';
        cell.dataset.position = cellPosition;
        const hex = document.createElement('div');
        hex.className = 'hex';
        hex.textContent = cellPosition;
        const marble = document.createElement('div');
        marble.className = 'marble empty';
        marble.dataset.position = cellPosition;
        cell.appendChild(hex);
        cell.appendChild(marble);
        row.appendChild(cell);
      }
      hexContainer.appendChild(row);
    }
    boardElement.appendChild(hexContainer);
  }

  // Update board display
  function updateBoardDisplay() {
    const marbles = document.querySelectorAll('.marble');
    marbles.forEach(marble => marble.className = 'marble empty');
    for (const position in gameState.board) {
      const color = gameState.board[position];
      const marble = document.querySelector(`.marble[data-position="${position}"]`);
      if (marble) marble.className = `marble ${color === 'b' ? 'black' : 'white'}`;
    }
  }

  // Update game info
  function updateGameInfo() {
    document.getElementById('black-count').textContent = gameState.blackCount;
    document.getElementById('white-count').textContent = gameState.whiteCount;
    document.getElementById('current-player').textContent = gameState.currentPlayer === 'b' ? 'Black' : 'White';
  }

  // AI move
  function makeAIMove() {
    document.getElementById('status-message').textContent = 'AI is thinking...';
    setTimeout(() => {
      const result = makeAIMoveFunc();
      updateBoardFromWasm();
      document.getElementById('status-message').textContent = 'AI made a move';
      updateBoardDisplay();
      updateGameInfo();

      if (result === 1) {
        document.getElementById('status-message').textContent = 'White wins!';
      } else if (result === 2) {
        document.getElementById('status-message').textContent = 'Black wins!';
      } else {
        // Switch to human's turn and update UI immediately
        gameState.currentPlayer = gameState.playerColor;
        updateGameInfo(); // Refresh UI to show human's turn
      }
    }, 1000);
  }

  // Move validation
  function isValidMoveFormat(move) {
    if (move.startsWith('i') && move.length >= 4) {
      const position = move.substring(1, 3);
      const direction = move.substring(3);
      return isValidPosition(position) && isValidDirection(direction);
    }
    if (move.startsWith('s') && move.length >= 6) {
      const position1 = move.substring(1, 3);
      const position2 = move.substring(3, 5);
      const direction = move.substring(5);
      return isValidPosition(position1) && isValidPosition(position2) && isValidDirection(direction);
    }
    return false;
  }

  function isValidPosition(pos) {
    if (pos.length !== 2) return false;
    const col = pos.charAt(0);
    const row = parseInt(pos.charAt(1));
    return col >= 'A' && col <= 'I' && row >= 1 && row <= 9;
  }

  function isValidDirection(dir) {
    const validDirections = ["NE", "E", "SE", "SW", "W", "NW"];
    return validDirections.includes(dir);
  }
</script>
</body>
</html>